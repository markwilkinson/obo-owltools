package owltools.ontologyrelease;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.log4j.Logger;

/**
 * Provide a staging directory for the release runners. 
 */
abstract class ReleaseRunnerFileTools {

	private static final String EXTENSIONS_DIRECTORY_NAME = "extensions";
	private static final String SUBSETS_DIRECTORY_NAME = "subsets";
	private static final String RELEASE_DIRECTORY_NAME = "releases";
	private static final String STAGING_DIRECTORY_NAME = "staging";
	private static final String STAGING_DIRECTORY_LOCK_FILE_NAME = ".lock";
	private static final String VERSION_INFO_FILE_NAME = "VERSION-INFO";
	
	// SimpleDateFormat is not thread safe
	private static ThreadLocal<DateFormat> dtFormat = new ThreadLocal<DateFormat>(){

		@Override
		protected DateFormat initialValue() {
			return new SimpleDateFormat("yyyy-MM-dd");
		}
	};
	
	private final File base;
	private final File staging;
	private final File lockFile;
	private final Logger logger;

	/**
	 * @param base directory
	 * @param logger
	 * @throws IOException
	 */
	ReleaseRunnerFileTools(File base, Logger logger) throws IOException {
		super();
		this.logger = logger;
		
		// base
		this.base = base;
		checkFolder(base);
		
		// staging directory
		staging = new File(base, STAGING_DIRECTORY_NAME);
		checkFolder(staging);
		
		// lock file
		lockFile = new File(staging, STAGING_DIRECTORY_LOCK_FILE_NAME);
		boolean success = lockFile.createNewFile();
		if (!success) {
			throw new IOException("Could not lock staging directory via lock file: "+lockFile.getAbsolutePath());
		}
		logger.info("Using staging folder for release manager: "+staging.getAbsolutePath());
		
		// clean staging
		cleanDirectory(staging, STAGING_DIRECTORY_LOCK_FILE_NAME);
		
		// sub directories
		File subsets = new File(staging, SUBSETS_DIRECTORY_NAME);
		checkFolder(subsets);

		File extensions = new File(staging, EXTENSIONS_DIRECTORY_NAME);
		checkFolder(extensions);
	}
	
	BufferedWriter getWriter(String fileName) throws IOException {
		return new BufferedWriter(new OutputStreamWriter(getOutputSteam(fileName), "UTF-8"));
	}
	
	OutputStream getOutputSteam(String fileName) throws IOException {
		// fail early, if the release manager would try to overwrite an existing file in the commit.
		checkNew(new File(base, fileName));
		// cleared: either overwrite is okay or is a new file 
		// But keep working in the staging directory
		File stagingFile = new File(staging, fileName);
		logger.info("saving to " + stagingFile.getAbsolutePath());
		return new FileOutputStream(stagingFile);
	}
	
	/**
	 * Set the ontology version id for a particular release. 
	 * If null, the current date is used.
	 * 
	 * @param version, version if available or null
	 * @return version
	 * @throws IOException
	 */
	String buildVersionInfo(String version) throws IOException {
		// fail early, if the release manager would try to overwrite an existing file in the commit.
		checkNew(new File(base, VERSION_INFO_FILE_NAME));
		// cleared: either overwrite is okay or is a new file 
		// But keep working in the staging directory
		File versionFile = checkNew(new File(staging, VERSION_INFO_FILE_NAME));
		logger.info("Creating version file: "+versionFile.getAbsolutePath());
		FileOutputStream outputStream = null;
		try {
			outputStream = new FileOutputStream(versionFile);
			String comments = null;
			if (version == null) {
				version = dtFormat.get().format(new Date());
				comments = "Auto Generated Version Number. Please do not edit this file.";
			}
			
			Properties prop = new Properties();
			prop.setProperty("version", version);
			prop.store(outputStream, comments);
			
			return version;
		}
		finally {
			IOUtils.closeQuietly(outputStream);
		}
	}
	
	private String readVersionInfo() {
		File versionFile = new File(base, VERSION_INFO_FILE_NAME);
		if (!versionFile.exists() || !versionFile.isFile() || !versionFile.canRead()) {
			return null;
		}
		FileInputStream inputStream = null;
		try {
			inputStream = new FileInputStream(versionFile);
			Properties prop = new Properties();
			prop.load(inputStream);
			return prop.getProperty("version");
		} catch (IOException e) {
			logger.info("Could not load old version info from file: "+versionFile.getAbsolutePath(), e);
		} finally {
			IOUtils.closeQuietly(inputStream);
		}
		return null;
	}
	
	/**
	 * Check whether the file is new. Throw an {@link IOException}, 
	 * if the file already exists and {@link #allowFileOverWrite} 
	 * is not set to true.
	 * 
	 * @param file
	 * @return file return the same file to allow chaining with other operations
	 * @throws IOException
	 */
	abstract File checkNew(File file) throws IOException;
	
	void commit(String version) throws IOException {
		File releasesFolder = new File(base, RELEASE_DIRECTORY_NAME);
		checkFolder(releasesFolder);
		
		// check if staging folder content is different than the last release
		String oldVersion = readVersionInfo();
		File oldVersionFolder = new File(releasesFolder, oldVersion);
		if (oldVersionFolder.exists() && oldVersionFolder.isDirectory()) {
			// check if the files in staging and oldVersion are the same
			// list files in staging and old-version, except lock and version
			FileFilter filter = createIngoreFilter(STAGING_DIRECTORY_LOCK_FILE_NAME, VERSION_INFO_FILE_NAME);
			File[] oldFiles = oldVersionFolder.listFiles(filter);
			File[] stagingFiles = staging.listFiles(filter);
			if (oldFiles.length == stagingFiles.length) {
				Arrays.sort(oldFiles);
				Arrays.sort(stagingFiles);
				boolean equals = true;
				for (int i = 0; i < stagingFiles.length && equals; i++) {
					final File oldFile = oldFiles[i];
					final File stagingFile = stagingFiles[i];
					equals = equals && oldFile.getName().equals(stagingFile.getName());
					if (equals) {
						if (!oldFile.isDirectory() && !stagingFile.isDirectory()) {
							// TODO decide, if the binary equals is sufficient
							// What about the embedded data version?
							equals = FileUtils.contentEquals(oldFile, stagingFile);
						}
						else {
							if (oldFile.isDirectory() && stagingFile.isDirectory()) {
								equals = equalsDirectory(oldFile, stagingFile);
							}
							else {
								equals = false;
							}
						}
					}
				}
				if (equals) {
					// check if base contains all the files from old-version
					// TODO
					
					// if all is true, skip release with message that the current relase would not change anything
					// TODO logger.info("");
					return;
				}
			}
		}
		// overwrite base folder content (if there is any)
		// as the user already must have allowed it, to get to this part of the code.
		
		// make version specific releases sub folder
		File versionFolder = new File(releasesFolder, version);
		checkFolder(versionFolder);
		
		// copy from staging directory into version specific releases folder
		copyContents(staging, versionFolder, STAGING_DIRECTORY_LOCK_FILE_NAME);
		
		// copy stuff from staging directory into the live directory
		copyContents(staging, base, STAGING_DIRECTORY_LOCK_FILE_NAME);
		
		// delete staging content, including the lock file
		FileUtils.cleanDirectory(staging);
	}
	
	private boolean equalsDirectory(File directory1, File directory2) throws IOException {
		if (FileUtils.isSymlink(directory1) || FileUtils.isSymlink(directory2)) {
			return false;
		}
		File[] files1 = directory1.listFiles();
		File[] files2 = directory2.listFiles();
		if (files1.length == 0 && files2.length == 0) {
			return true;
		}
		if (files1.length != files2.length) {
			return false;
		}
		Arrays.sort(files1);
		Arrays.sort(files2);
		boolean equals = true;
		for (int i = 0; i < files1.length && equals; i++) {
			File file1 = files1[i];
			File file2 = files2[i];
			if (file1.isFile() && file2.isFile()) {
				equals = FileUtils.contentEquals(file1, file2);
			}
			else {
				if (file1.isDirectory() && file2.isDirectory()) {
					equals = equalsDirectory(file1, file2);
				}
				else {
					equals = false;
				}
			}
		}
		return equals;
	}

	private void copyContents(File sourceFolder, File targetFolder, final String...ignores) throws IOException {
		FileUtils.copyDirectory(sourceFolder, targetFolder, createIngoreFilter(ignores), true);
	}
	
	
	/**
	 * Clean a directory, by deleting all files and folders in it. Retain the 
	 * top level files or folders, if their names are in the ignores array.
	 * 
	 * @param folder
	 * @param ignores
	 * @throws IOException
	 */
	private void cleanDirectory(final File folder, final String...ignores) throws IOException {
		File[] files = folder.listFiles(createIngoreFilter(ignores));
		if (files.length > 0) {
			logger.info("Cleaning folder: "+folder.getAbsolutePath());
			for (File file : files) {
				if (!FileUtils.isSymlink(file)) {
					// if file is symlink, do not recurse, only delete the link.
					file.delete();
				} else {
					FileUtils.forceDelete(file);
				}
			}
		}
	}
	
	private static FileFilter createIngoreFilter(final String...ignores) {
		FileFilter filter = null;
		if (ignores != null && ignores.length > 0) {
			filter = new FileFilter() {
				Set<String> names = createSet(ignores);
				
				@Override
				public boolean accept(File pathname) {
					return !names.contains(pathname.getName());
				}
			};
		}
		return filter;
	}
	
	private static <T> Set<T> createSet(T[] values) {
		if (values.length == 1) {
			return Collections.singleton(values[0]);
		}
		return new HashSet<T>(Arrays.asList(values));
	}
	
	static void checkFolder(File folder) throws IOException {
		FileUtils.forceMkdir(folder);
		if (!folder.exists()) {
			throw new IOException("Could not create directory: "+folder.getAbsolutePath());
		}
		if (!folder.isDirectory()) {
			throw new IOException(folder.getAbsolutePath()+" already exists, but is not a directory");
		}
		if (!folder.canWrite()) {
			throw new IOException("Can't write in directory: "+folder.getAbsolutePath());
		}
	}
	
}
